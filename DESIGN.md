This is my design file where I will discuss how the project works and what I did to create the project.

I chose to create this website with flask because I knew that the features that I wanted to intergrate into the website were going to be easier to implement in Python. I knew from the beginning that I wanted to implement features of astropy and make it more user friendly and so flask was the natural choice especially because it was a follow up from week 8 when we designed CS50 finance. 

As you can see there are alot of imports for modules. There are a couple important imports that deserve recognition. The first being the imports tied to the core of the project, namely astropy and astroquery. These two modules allow me to actively query the Horizons Database from JPL and recieve the data. For astroquery we had to configure that server that we use to query for JPL because some aspects of the astroquery repository on github are beign reworked. The first thing we do is define the locate function. This function will query JPL Horizons for us by taking in the object name you want to query as one of the parameters. That object name has to be compatible with the query otherwise the service malfunctions. We can also find data for our object for a specified period of time. In the Horizons function this time is taken as a dictionary input labelled epoch. There are two different time spans we are concerned about, a year time span incremented by 30 days and a daily time span incremented by an hour. After running the function in return we get a dictionary which we store in an object variable called eph which is standard nomenclature in image pipelines issued by JPL.

The next part of the program uses datetime and goecoder to get logitude and latitude for the user whose location is based on their ip address and their time stamp is also based on location as well. The logitude and latitude function will become important when trying to calcuate orbits with repect to the user's location and time will serve a similar function. 

After that we set up our base_dir, upload folder and SQL database. This will be needed for displaying the images that users upload to the website. The upload folder is located in the static folder so that flask can find the files when the application is running. I needed to define a base directory due to some errors in running certain html files like display.html and upload.html in flask. The SQL database stores the name of the images uploaded and the time they were uploaded at so that we can display the images in order by relavance according to time. The names are sotred so one can go back and query the files we want to display. I could have made an active list but that list would be temproray and would be wiped out with every session so I wanted to create an object that would store the names of all of the files that I uploaded because then I could display them all at the same time without much difficult. The workaround would have been inefficent and perhaps difficult to implement and would involve selecting all files that had certain image tags in their file names such as .jpg, .gif etc. 

After I configure the flask application I define the make_png function. This function was perhaps the most difficult to make and the most time sonsuming because it is the mainstay of the oribit modelling website. Essentially the function takes the object name as input and runs the locate function in order to get an emphemeris in the form of a dictionary from the user. The function the takes the right acension values from the dictionary and the declination values in order to get values in terms of astronomical units for the location of the planet. Then we implement some really cool math. So what we first do is that we take the array of 'RA' and 'DEC' and then we convert those coordinates in terms of cartesian coordinates in x,y,z so that we can plot them using some linear algebra. The math portion was difficult to implment because the some of the matrices originally came out with the woring orientation and thus we could not multiply them toghether because the dimensions were off. Next we create a matrix of mesh values that will help us create a wireframe around our 3d earth. 

In the next step I had to borrow some code. Here essentially what I had before was a simple 3D surface plot that I created using the mpld3 module. But the issue was that it didn't really help becasue it was a simple color gradient and no user would be able to tell where the orbit was on the Earth. I wanted to take a map of the Earth and turn it into a color map so that I could display it as a surface by assigning each long,lat value in the array a pixel color value from that image. With the help of some lines from author 'sulkeh' I was able to take this color map and fit the surface plot into the wireframe I generated. I then plot the scatter of the annual oribit of the object by superimposing it on the wireplot and using it as a 3d grid. THat way the user can see the optimal location from which to view the queried object year-round. Next I plot the 24 hour ephemeris data to create the parabolic shape that forms from the the rotation of the Earth on its tilted axis so the user can see the motion of the object queried as it goes above and below the horizon. This data unlike the global data is dependant on the user's location. I used a matplotlib scatter plot to display this data and the axline function in the color red to distinctly indicate the current time point at which the object was located in its parabolic motion. 

The issue with mpld3 and flask is that with flask there still is not a single way to create an interactive matplotlib plot in 3D. So while the generated plot would be able to be moved by a user's mouse if the user was viewing the plot generated outside of flask, the same cannot be said about the plot inside of matplotlib. The way I worked around this problem is by changing the view of the plot using the view_init() method which takes in the parameter of the angle by which one would want to rotate the plot and the angle from which they want to view the plot. Then I initialized the plot with each respective view and saved the plots as png images. In the html template home.html I wrote a JS script that uodates the window about every 1 second and every time it updates the window it rotates throught the plot, so that the user gets an animated visual of the orbital diagram. 

I knew this would take a long time so I found a cool loading gif online and what I did was that I saved the gif to my images folder inside of my static folder and then I displayed it in a div. But when I did is that I first set the div to a a CSS class that made the image invisible by setting the display value to NULL and then when the button is pressed I ran a function in JS that redefined the class of that div to one that defined display as block so that right as you press the button the cool loading gif comes up and it give the user something nice to look at while their data is being complied. 

The next part I implemented was the simple application link to the different images of Saturn, Jupiter, and the Moon which I implemented by rendering templates with those specified images from the layout tab and linked those paths to the navbar. 

Next comes the data function part of the website. Obviously it takes alot of data to generate plots of orbital trajectories and there are alot of other relavant parts of the data that could be used so what I did was that I created a the data function a call for the locate function. Esentially the user inputs the object they want data about in the first template and after they press enter I launch another loading screen which is done by tying a JS script function to the button that make another div visible again after it is pressed. After the program has compiled the data it outputs every row of the data given by JPL, organized by its timestamp. Then I added an html download tab that downloads the csv of the data to the local download files of the computer when it is pressed. 

The next part of the website is the image upload and display tabs. The upload tab has a file entry that I coded in html. The entry has restrictions on what kind of file the user can upload and what it does is that when the user chooses the file from the local repository, the function saves the name of the file and a timestamp in the SQL database that allows the website to go backand retreive that file by name. The file is then sent the the uploads part of the static folder. If it were left in the same directory as the flask application, I could not use the images to be displayed in any of my templates since flask would not recognize it. This took me a long time to figure out. Moreover, this way by saving it to a separate folder in static it allows me to declutter my files in my file tree. Then after uploading the images, the app redirect the user to a webpage where all of the previously uploaded pictures at in a template called uploaded.html. Here what I do is that I query all of the names of the images and their dates that are stored in the SQL database and I pass that data as a list to the render_template function. The html template has a for loop that goes through and creates a separate div for every image so that they can all be dsiplayed as well as a timestamp next to the image to show when the image was uploaded. 
